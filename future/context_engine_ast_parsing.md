# AST Analysis: Парсинг вместо LLM

## Статус: ✅ РЕАЛИЗОВАНО — Фаза 6

## Принцип: AST не галлюцинирует

```
❌ LLM: "В файле примерно 5 функций..."
✅ AST: "В файле ровно 7 функций: main, process_data, validate, ..."
```

**Где применять AST:**
- Подсчёт функций/классов
- Граф зависимостей (imports)
- Метрики кода (LOC, complexity)
- Структура проекта

**Где оставить LLM:**
- Понимание intent пользователя
- Генерация нового кода
- Объяснение что делает код

---

## Текущее состояние

**Context Engine** работает с ограничениями:
- ✅ Разбиение кода на чанки
- ✅ BM25 для релевантности
- ❌ Не учитывает imports/зависимости
- ❌ Не понимает структуру проекта

## Проблема

**Небольшие модели (7B-13B) не могут обработать большие кодовые базы (50-500K токенов) в контексте (4-8K).**

Простой RAG через ChromaDB не учитывает структуру кода и зависимости. Для понимания контекста нужно знать:
- Какие модули импортирует код
- Какие функции/классы вызываются
- Какие части кода наиболее важны (часто используются)

## Решение: AST парсинг

### Зачем нужно:
1. **Граф зависимостей** — понимание структуры проекта
2. **Приоритизация важности** — какие части кода используются чаще
3. **Умный контекст** — включать связанные модули и функции
4. **Эффективное использование токенов** — только релевантный код

### Что нужно реализовать:

#### 1. AST парсинг Python кода
```python
def _parse_ast_dependencies(file_path: str, content: str) -> DependencyInfo:
    """Парсит AST и извлекает зависимости.
    
    Returns:
        DependencyInfo с:
        - imports: список импортированных модулей/функций
        - functions: список функций и их сигнатур
        - classes: список классов и методов
        - calls: вызовы функций/методов в коде
    """
```

#### 2. Построение графа зависимостей
```python
class DependencyGraph:
    """Граф зависимостей между модулями проекта."""
    
    def add_module(self, module_path: str, dependencies: List[str]):
        """Добавляет модуль и его зависимости."""
    
    def get_dependent_modules(self, module_path: str) -> List[str]:
        """Возвращает модули, которые зависят от данного."""
    
    def calculate_importance(self, module_path: str) -> float:
        """Вычисляет важность модуля (PageRank-like)."""
```

#### 3. Приоритизация чанков по зависимостям
```python
def _prioritize_by_dependencies(
    chunks: List[CodeChunk],
    query: str,
    dependency_graph: DependencyGraph
) -> List[ScoredChunk]:
    """Приоритизирует чанки на основе зависимостей.
    
    Учитывает:
    - Релевантность запросу (BM25)
    - Важность модуля (PageRank)
    - Зависимости от других модулей
    """
```

#### 4. Улучшенная стратегия сборки контекста
```python
class DependencyAwareComposer(ContextComposer):
    """Композитор контекста с учётом зависимостей."""
    
    def compose(
        self,
        scored_chunks: List[ScoredChunk],
        query: str,
        dependency_graph: DependencyGraph
    ) -> str:
        """Собирает контекст с учётом зависимостей.
        
        Логика:
        1. Выбирает самые релевантные чанки
        2. Добавляет зависимости этих чанков
        3. Уважает лимит токенов
        """
```

## Реализация

### Фаза 1: Базовый AST парсинг
- Использовать стандартный модуль `ast` Python
- Парсить только Python файлы (остальные — через regex как сейчас)
- Извлекать imports, функции, классы, вызовы

### Фаза 2: Граф зависимостей
- Строить граф по проекту
- Вычислять важность модулей
- Кэшировать граф в памяти/файле

### Фаза 3: Интеграция в Context Engine
- Использовать граф для приоритизации
- Добавить стратегию "DEPENDENCY_AWARE"
- Обновить метод `get_context()`

## Оценка сложности

- **Фаза 1**: 1-2 дня (AST парсинг)
- **Фаза 2**: 2-3 дня (граф зависимостей, PageRank)
- **Фаза 3**: 1 день (интеграция)

**Итого:** 4-6 дней

## Риски

1. **Производительность**: Парсинг больших проектов может быть медленным
   - **Митигация**: Кэшировать результаты, парсить только при индексации

2. **Сложность AST**: Не все Python конструкции легко парсить
   - **Митигация**: Начать с простых случаев (imports, def, class)

3. **Поддержка языков**: Только Python, остальные языки — через regex
   - **Митигация**: Расширить позже (tree-sitter для других языков)

## Преимущества

- ✅ Улучшенное качество контекста для больших проектов
- ✅ Более точная релевантность чанков
- ✅ Эффективное использование токенов
- ✅ Поддержка больших кодовых баз для маленьких моделей

## Связанные компоненты

- `infrastructure/context_engine.py` — основной файл для изменений
- [legacy_architecture_contract.md](legacy_architecture_contract.md) — описание Context Engine из CORE26
- `lern.md` — описание Context Manager в архитектуре

---

## Checklist

- [x] Создать `infrastructure/ast_analyzer.py`
- [x] Реализовать подсчёт функций/классов
- [x] Реализовать извлечение imports
- [x] Реализовать граф зависимостей (DependencyGraph)
- [x] Метрики кода (LOC, cyclomatic complexity)
- [x] Интеграция в `analyze` режим (ChatAgent)
- [x] Тесты (27 шт.)

---

## Связанные документы

- `tree_sitter_multilang.md` — мультиязычный парсинг (после AST)
