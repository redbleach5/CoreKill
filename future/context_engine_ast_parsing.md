# Улучшение Context Engine: AST парсинг для анализа зависимостей

## Текущее состояние

**Context Engine v0.1** работает без AST парсинга:
- Использует regex для поиска функций и классов
- Не строит граф зависимостей кода
- Не анализирует imports и вызовы функций
- Приоритизация чанков только на основе релевантности запроса (BM25)

### Что работает сейчас:
- ✅ Умное разбиение кода на чанки (учитывает границы функций/классов)
- ✅ Оценка релевантности через BM25 и ключевые слова
- ✅ Сборка оптимального контекста в пределах лимита токенов
- ✅ Кэширование индекса проекта

### Ограничения:
- ❌ Не учитывает зависимости между модулями (imports)
- ❌ Не понимает вызовы функций между файлами
- ❌ Не может определить важность кода на основе использования
- ❌ Для больших проектов может выбирать нерелевантные чанки

## Проблема

**Небольшие модели (7B-13B) не могут обработать большие кодовые базы (50-500K токенов) в контексте (4-8K).**

Простой RAG через ChromaDB не учитывает структуру кода и зависимости. Для понимания контекста нужно знать:
- Какие модули импортирует код
- Какие функции/классы вызываются
- Какие части кода наиболее важны (часто используются)

## Решение: AST парсинг

### Зачем нужно:
1. **Граф зависимостей** — понимание структуры проекта
2. **Приоритизация важности** — какие части кода используются чаще
3. **Умный контекст** — включать связанные модули и функции
4. **Эффективное использование токенов** — только релевантный код

### Что нужно реализовать:

#### 1. AST парсинг Python кода
```python
def _parse_ast_dependencies(file_path: str, content: str) -> DependencyInfo:
    """Парсит AST и извлекает зависимости.
    
    Returns:
        DependencyInfo с:
        - imports: список импортированных модулей/функций
        - functions: список функций и их сигнатур
        - classes: список классов и методов
        - calls: вызовы функций/методов в коде
    """
```

#### 2. Построение графа зависимостей
```python
class DependencyGraph:
    """Граф зависимостей между модулями проекта."""
    
    def add_module(self, module_path: str, dependencies: List[str]):
        """Добавляет модуль и его зависимости."""
    
    def get_dependent_modules(self, module_path: str) -> List[str]:
        """Возвращает модули, которые зависят от данного."""
    
    def calculate_importance(self, module_path: str) -> float:
        """Вычисляет важность модуля (PageRank-like)."""
```

#### 3. Приоритизация чанков по зависимостям
```python
def _prioritize_by_dependencies(
    chunks: List[CodeChunk],
    query: str,
    dependency_graph: DependencyGraph
) -> List[ScoredChunk]:
    """Приоритизирует чанки на основе зависимостей.
    
    Учитывает:
    - Релевантность запросу (BM25)
    - Важность модуля (PageRank)
    - Зависимости от других модулей
    """
```

#### 4. Улучшенная стратегия сборки контекста
```python
class DependencyAwareComposer(ContextComposer):
    """Композитор контекста с учётом зависимостей."""
    
    def compose(
        self,
        scored_chunks: List[ScoredChunk],
        query: str,
        dependency_graph: DependencyGraph
    ) -> str:
        """Собирает контекст с учётом зависимостей.
        
        Логика:
        1. Выбирает самые релевантные чанки
        2. Добавляет зависимости этих чанков
        3. Уважает лимит токенов
        """
```

## Реализация

### Фаза 1: Базовый AST парсинг
- Использовать стандартный модуль `ast` Python
- Парсить только Python файлы (остальные — через regex как сейчас)
- Извлекать imports, функции, классы, вызовы

### Фаза 2: Граф зависимостей
- Строить граф по проекту
- Вычислять важность модулей
- Кэшировать граф в памяти/файле

### Фаза 3: Интеграция в Context Engine
- Использовать граф для приоритизации
- Добавить стратегию "DEPENDENCY_AWARE"
- Обновить метод `get_context()`

## Оценка сложности

- **Фаза 1**: 1-2 дня (AST парсинг)
- **Фаза 2**: 2-3 дня (граф зависимостей, PageRank)
- **Фаза 3**: 1 день (интеграция)

**Итого:** 4-6 дней

## Риски

1. **Производительность**: Парсинг больших проектов может быть медленным
   - **Митигация**: Кэшировать результаты, парсить только при индексации

2. **Сложность AST**: Не все Python конструкции легко парсить
   - **Митигация**: Начать с простых случаев (imports, def, class)

3. **Поддержка языков**: Только Python, остальные языки — через regex
   - **Митигация**: Расширить позже (tree-sitter для других языков)

## Преимущества

- ✅ Улучшенное качество контекста для больших проектов
- ✅ Более точная релевантность чанков
- ✅ Эффективное использование токенов
- ✅ Поддержка больших кодовых баз для маленьких моделей

## Связанные компоненты

- `infrastructure/context_engine.py` — основной файл для изменений
- `.cursor/rules/legacy_architecture_contract.md` — описание Context Engine из CORE26
- `lern.md` — описание Context Manager в архитектуре

## Статус

**Приоритет:** Низкий (опциональное улучшение)

**Зависимости:** Нет (можно реализовать независимо)

**Готовность к реализации:** После основного функционала (Debugger, Self-Healing)
